/*
 * This file is generated by jOOQ.
 */
package eki.ekilex.data.db.main.tables;


import eki.ekilex.data.db.main.Public;
import eki.ekilex.data.db.main.tables.records.ViewWwLexemeRecord;

import java.math.BigDecimal;

import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.JSON;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class ViewWwLexeme extends TableImpl<ViewWwLexemeRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.view_ww_lexeme</code>
     */
    public static final ViewWwLexeme VIEW_WW_LEXEME = new ViewWwLexeme();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<ViewWwLexemeRecord> getRecordType() {
        return ViewWwLexemeRecord.class;
    }

    /**
     * The column <code>public.view_ww_lexeme.lexeme_id</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> LEXEME_ID = createField(DSL.name("lexeme_id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.word_id</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> WORD_ID = createField(DSL.name("word_id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.meaning_id</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> MEANING_ID = createField(DSL.name("meaning_id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_code</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> DATASET_CODE = createField(DSL.name("dataset_code"), SQLDataType.VARCHAR(10), this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_name</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> DATASET_NAME = createField(DSL.name("dataset_name"), SQLDataType.CLOB, this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_type</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> DATASET_TYPE = createField(DSL.name("dataset_type"), SQLDataType.VARCHAR(10), this, "");

    /**
     * The column <code>public.view_ww_lexeme.value_state_code</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> VALUE_STATE_CODE = createField(DSL.name("value_state_code"), SQLDataType.VARCHAR(100), this, "");

    /**
     * The column <code>public.view_ww_lexeme.proficiency_level_code</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> PROFICIENCY_LEVEL_CODE = createField(DSL.name("proficiency_level_code"), SQLDataType.VARCHAR(100), this, "");

    /**
     * The column <code>public.view_ww_lexeme.reliability</code>.
     */
    public final TableField<ViewWwLexemeRecord, Integer> RELIABILITY = createField(DSL.name("reliability"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.view_ww_lexeme.level1</code>.
     */
    public final TableField<ViewWwLexemeRecord, Integer> LEVEL1 = createField(DSL.name("level1"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.view_ww_lexeme.level2</code>.
     */
    public final TableField<ViewWwLexemeRecord, Integer> LEVEL2 = createField(DSL.name("level2"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.view_ww_lexeme.weight</code>.
     */
    public final TableField<ViewWwLexemeRecord, BigDecimal> WEIGHT = createField(DSL.name("weight"), SQLDataType.NUMERIC(5, 4), this, "");

    /**
     * The column <code>public.view_ww_lexeme.lexeme_order_by</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> LEXEME_ORDER_BY = createField(DSL.name("lexeme_order_by"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_order_by</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> DATASET_ORDER_BY = createField(DSL.name("dataset_order_by"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.register_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> REGISTER_CODES = createField(DSL.name("register_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.pos_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> POS_CODES = createField(DSL.name("pos_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.region_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> REGION_CODES = createField(DSL.name("region_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.deriv_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> DERIV_CODES = createField(DSL.name("deriv_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.lexeme_notes</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> LEXEME_NOTES = createField(DSL.name("lexeme_notes"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.grammars</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> GRAMMARS = createField(DSL.name("grammars"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.governments</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> GOVERNMENTS = createField(DSL.name("governments"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.usages</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> USAGES = createField(DSL.name("usages"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.source_links</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> SOURCE_LINKS = createField(DSL.name("source_links"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.meaning_words</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> MEANING_WORDS = createField(DSL.name("meaning_words"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.is_ww_unif</code>.
     */
    public final TableField<ViewWwLexemeRecord, Boolean> IS_WW_UNIF = createField(DSL.name("is_ww_unif"), SQLDataType.BOOLEAN, this, "");

    /**
     * The column <code>public.view_ww_lexeme.is_ww_lite</code>.
     */
    public final TableField<ViewWwLexemeRecord, Boolean> IS_WW_LITE = createField(DSL.name("is_ww_lite"), SQLDataType.BOOLEAN, this, "");

    /**
     * The column <code>public.view_ww_lexeme.is_ww_os</code>.
     */
    public final TableField<ViewWwLexemeRecord, Boolean> IS_WW_OS = createField(DSL.name("is_ww_os"), SQLDataType.BOOLEAN, this, "");

    private ViewWwLexeme(Name alias, Table<ViewWwLexemeRecord> aliased) {
        this(alias, aliased, null);
    }

    private ViewWwLexeme(Name alias, Table<ViewWwLexemeRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.view("" + "create view \"view_ww_lexeme\" as  SELECT l.id AS lexeme_id,\n    l.word_id,\n    l.meaning_id,\n    l.dataset_code,\n    l.dataset_name,\n    l.dataset_type,\n    l.value_state_code,\n    l.proficiency_level_code,\n    l.reliability,\n    l.level1,\n    l.level2,\n    l.weight,\n    l.order_by AS lexeme_order_by,\n    l.dataset_order_by,\n    l_reg.register_codes,\n    l_pos.pos_codes,\n    l_rgn.region_codes,\n    l_der.deriv_codes,\n    l_not.lexeme_notes,\n    l_gra.grammars,\n    l_gov.governments,\n    l_usa.usages,\n    l_src.source_links,\n    l_mea.meaning_words,\n    l.is_ww_unif,\n    l.is_ww_lite,\n    l.is_ww_os\n   FROM ((((((((((( SELECT l_1.id,\n            l_1.word_id,\n            l_1.meaning_id,\n            l_1.dataset_code,\n            l_1.value_state_code,\n            l_1.proficiency_level_code,\n            l_1.reliability,\n            l_1.level1,\n            l_1.level2,\n            l_1.weight,\n            l_1.order_by,\n            ((EXISTS ( SELECT p.id\n                   FROM publishing p\n                  WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l_1.id)))) OR ((l_1.dataset_code)::text <> 'eki'::text)) AS is_ww_unif,\n            (EXISTS ( SELECT p.id\n                   FROM publishing p\n                  WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l_1.id)))) AS is_ww_lite,\n            (EXISTS ( SELECT p.id\n                   FROM publishing p\n                  WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l_1.id)))) AS is_ww_os,\n            ds.type AS dataset_type,\n            ds.name AS dataset_name,\n            ds.order_by AS dataset_order_by\n           FROM lexeme l_1,\n            dataset ds\n          WHERE (((l_1.dataset_code)::text = (ds.code)::text) AND (l_1.is_word = true) AND (l_1.is_public = true) AND (ds.is_public = true) AND ((l_1.dataset_code)::text <> 'ety'::text) AND ((EXISTS ( SELECT p.id\n                   FROM publishing p\n                  WHERE (((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l_1.id)))) OR ((l_1.dataset_code)::text <> 'eki'::text)))) l\n     LEFT JOIN ( SELECT lr.lexeme_id,\n            array_agg(lr.register_code ORDER BY lr.order_by) AS register_codes\n           FROM lexeme_register lr\n          GROUP BY lr.lexeme_id) l_reg ON ((l_reg.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lp.lexeme_id,\n            array_agg(lp.pos_code ORDER BY lp.order_by) AS pos_codes\n           FROM lexeme_pos lp\n          GROUP BY lp.lexeme_id) l_pos ON ((l_pos.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lr.lexeme_id,\n            array_agg(lr.region_code ORDER BY lr.order_by) AS region_codes\n           FROM lexeme_region lr\n          GROUP BY lr.lexeme_id) l_rgn ON ((l_rgn.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT ld.lexeme_id,\n            array_agg(ld.deriv_code) AS deriv_codes\n           FROM lexeme_deriv ld\n          GROUP BY ld.lexeme_id) l_der ON ((l_der.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT ln.lexeme_id,\n            json_agg(json_build_object('id', ln.lexeme_note_id, 'value', ln.value, 'valuePrese', ln.value_prese, 'lang', ln.lang, 'createdBy', ln.created_by, 'createdOn', ln.created_on, 'modifiedBy', ln.modified_by, 'modifiedOn', ln.modified_on, 'orderBy', ln.order_by, 'wwUnif', ln.is_ww_unif, 'wwLite', ln.is_ww_lite, 'wwOs', ln.is_ww_os, 'sourceLinks', ( SELECT json_agg(json_build_object('sourceLinkId', lnsl.id, 'sourceLinkName', lnsl.name, 'orderBy', lnsl.order_by, 'sourceId', s.id, 'sourceName', s.name, 'sourceValue', s.value, 'sourceValuePrese', s.value_prese, 'sourcePublic', s.is_public) ORDER BY lnsl.order_by) AS json_agg\n                   FROM lexeme_note_source_link lnsl,\n                    source s\n                  WHERE ((lnsl.lexeme_note_id = ln.lexeme_note_id) AND (lnsl.source_id = s.id)))) ORDER BY ln.order_by) AS lexeme_notes\n           FROM ( SELECT ln_1.id AS lexeme_note_id,\n                    ln_1.lexeme_id,\n                    ln_1.value,\n                    ln_1.value_prese,\n                    ln_1.lang,\n                    ln_1.created_by,\n                    ln_1.created_on,\n                    ln_1.modified_by,\n                    ln_1.modified_on,\n                    ln_1.order_by,\n                    ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'lexeme_note'::text) AND (p.entity_id = ln_1.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = ln_1.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))) AS is_ww_unif,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'lexeme_note'::text) AND (p.entity_id = ln_1.id)))) AS is_ww_lite,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'lexeme_note'::text) AND (p.entity_id = ln_1.id)))) AS is_ww_os\n                   FROM lexeme_note ln_1\n                  WHERE ((ln_1.is_public = true) AND ((EXISTS ( SELECT 1\n                           FROM publishing p\n                          WHERE (((p.entity_name)::text = 'lexeme_note'::text) AND (p.entity_id = ln_1.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = ln_1.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))))) ln\n          GROUP BY ln.lexeme_id) l_not ON ((l_not.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lg.lexeme_id,\n            json_agg(json_build_object('id', lg.id, 'value', lg.value, 'valuePrese', lg.value_prese, 'lang', lg.lang, 'createdBy', lg.created_by, 'createdOn', lg.created_on, 'modifiedBy', lg.modified_by, 'modifiedOn', lg.modified_on, 'orderBy', lg.order_by, 'wwUnif', lg.is_ww_unif, 'wwLite', lg.is_ww_lite, 'wwOs', lg.is_ww_os) ORDER BY lg.order_by) AS grammars\n           FROM ( SELECT g.id,\n                    g.lexeme_id,\n                    g.value,\n                    g.value_prese,\n                    g.lang,\n                    g.created_by,\n                    g.created_on,\n                    g.modified_by,\n                    g.modified_on,\n                    g.order_by,\n                    ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'grammar'::text) AND (p.entity_id = g.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = g.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))) AS is_ww_unif,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'grammar'::text) AND (p.entity_id = g.id)))) AS is_ww_lite,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'grammar'::text) AND (p.entity_id = g.id)))) AS is_ww_os\n                   FROM grammar g\n                  WHERE ((EXISTS ( SELECT 1\n                           FROM publishing p\n                          WHERE (((p.entity_name)::text = 'grammar'::text) AND (p.entity_id = g.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = g.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[]))))))) lg\n          GROUP BY lg.lexeme_id) l_gra ON ((l_gra.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lg.lexeme_id,\n            json_agg(json_build_object('id', lg.id, 'value', lg.value, 'createdBy', lg.created_by, 'createdOn', lg.created_on, 'modifiedBy', lg.modified_by, 'modifiedOn', lg.modified_on, 'orderBy', lg.order_by, 'wwUnif', lg.is_ww_unif, 'wwLite', lg.is_ww_lite, 'wwOs', lg.is_ww_os) ORDER BY lg.order_by) AS governments\n           FROM ( SELECT g.id,\n                    g.lexeme_id,\n                    g.value,\n                    g.created_by,\n                    g.created_on,\n                    g.modified_by,\n                    g.modified_on,\n                    g.order_by,\n                    ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'government'::text) AND (p.entity_id = g.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = g.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))) AS is_ww_unif,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'government'::text) AND (p.entity_id = g.id)))) AS is_ww_lite,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'government'::text) AND (p.entity_id = g.id)))) AS is_ww_os\n                   FROM government g\n                  WHERE ((EXISTS ( SELECT 1\n                           FROM publishing p\n                          WHERE (((p.entity_name)::text = 'government'::text) AND (p.entity_id = g.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = g.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[]))))))) lg\n          GROUP BY lg.lexeme_id) l_gov ON ((l_gov.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT mw.lexeme_id,\n            json_agg(json_build_object('lexemeId', mw.lexeme_id, 'meaningId', mw.meaning_id, 'mwLexemeId', mw.mw_lexeme_id, 'mwLexemeWeight', mw.mw_lexeme_weight, 'mwLexemeGovernments', mw.mw_lexeme_governments, 'mwLexemeRegisterCodes', mw.mw_lexeme_register_codes, 'mwLexemeValueStateCode', mw.mw_lexeme_value_state_code, 'wordId', mw.mw_word_id, 'value', mw.mw_value, 'valuePrese', mw.mw_value_prese, 'homonymNr', mw.mw_homonym_nr, 'lang', mw.mw_lang, 'aspectCode', mw.mw_aspect_code, 'wordTypeCodes', mw.mw_word_type_codes, 'wwUnif', mw.is_ww_unif, 'wwLite', mw.is_ww_lite, 'wwOs', mw.is_ww_os) ORDER BY mw.hw_lexeme_reliability, mw.hw_lexeme_level1, mw.hw_lexeme_level2, mw.hw_lexeme_order_by, mw.mw_lexeme_order_by) AS meaning_words\n           FROM ( SELECT l1.word_id,\n                    l1.id AS lexeme_id,\n                    l1.meaning_id,\n                    l1.reliability AS hw_lexeme_reliability,\n                    l1.level1 AS hw_lexeme_level1,\n                    l1.level2 AS hw_lexeme_level2,\n                    l1.order_by AS hw_lexeme_order_by,\n                    l2.id AS mw_lexeme_id,\n                    l2.value_state_code AS mw_lexeme_value_state_code,\n                    l2.weight AS mw_lexeme_weight,\n                    l2.order_by AS mw_lexeme_order_by,\n                    ( SELECT json_agg(json_build_object('id', g.id, 'value', g.value, 'createdBy', g.created_by, 'createdOn', g.created_on, 'modifiedBy', g.modified_by, 'modifiedOn', g.modified_on, 'orderBy', g.order_by, 'wwUnif', g.is_ww_unif, 'wwLite', g.is_ww_lite, 'wwOs', g.is_ww_os) ORDER BY g.order_by) AS json_agg\n                           FROM ( SELECT g_1.id,\n                                    g_1.lexeme_id,\n                                    g_1.value,\n                                    g_1.created_by,\n                                    g_1.created_on,\n                                    g_1.modified_by,\n                                    g_1.modified_on,\n                                    g_1.order_by,\n                                    ((EXISTS ( SELECT p.id\n   FROM publishing p\n  WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'government'::text) AND (p.entity_id = g_1.id)))) OR (EXISTS ( SELECT 1\n   FROM lexeme l_1\n  WHERE ((l_1.id = g_1.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))) AS is_ww_unif,\n                                    (EXISTS ( SELECT p.id\n   FROM publishing p\n  WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'government'::text) AND (p.entity_id = g_1.id)))) AS is_ww_lite,\n                                    (EXISTS ( SELECT p.id\n   FROM publishing p\n  WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'government'::text) AND (p.entity_id = g_1.id)))) AS is_ww_os\n                                   FROM government g_1\n                                  WHERE ((g_1.lexeme_id = l2.id) AND ((EXISTS ( SELECT 1\n   FROM publishing p\n  WHERE (((p.entity_name)::text = 'government'::text) AND (p.entity_id = g_1.id)))) OR (EXISTS ( SELECT 1\n   FROM lexeme l_1\n  WHERE ((l_1.id = g_1.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))))) g) AS mw_lexeme_governments,\n                    ( SELECT array_agg(lr.register_code ORDER BY lr.order_by) AS array_agg\n                           FROM lexeme_register lr\n                          WHERE (lr.lexeme_id = l2.id)\n                          GROUP BY lr.lexeme_id) AS mw_lexeme_register_codes,\n                    ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l2.id)))) OR ((l2.dataset_code)::text <> 'eki'::text)) AS is_ww_unif,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l2.id)))) AS is_ww_lite,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l2.id)))) AS is_ww_os,\n                    w2.id AS mw_word_id,\n                    w2.value AS mw_value,\n                    w2.value_prese AS mw_value_prese,\n                    w2.homonym_nr AS mw_homonym_nr,\n                    w2.lang AS mw_lang,\n                    w2.aspect_code AS mw_aspect_code,\n                    ( SELECT array_agg(wt.word_type_code ORDER BY wt.order_by) AS array_agg\n                           FROM word_word_type wt\n                          WHERE ((wt.word_id = w2.id) AND ((wt.word_type_code)::text <> ALL ((ARRAY['vv'::character varying, 'yv'::character varying, 'vvar'::character varying])::text[])))\n                          GROUP BY wt.word_id) AS mw_word_type_codes\n                   FROM ((((lexeme l1\n                     JOIN dataset ds1 ON (((ds1.code)::text = (l1.dataset_code)::text)))\n                     JOIN lexeme l2 ON (((l2.meaning_id = l1.meaning_id) AND (l2.id <> l1.id) AND (l2.word_id <> l1.word_id) AND ((COALESCE(l2.value_state_code, 'anything'::character varying))::text <> 'vigane'::text))))\n                     JOIN dataset ds2 ON (((ds2.code)::text = (l2.dataset_code)::text)))\n                     JOIN word w2 ON ((w2.id = l2.word_id)))\n                  WHERE ((l1.is_public = true) AND (l1.is_word = true) AND (l2.is_public = true) AND (l2.is_word = true) AND (ds1.is_public = true) AND (ds2.is_public = true) AND (w2.is_public = true) AND ((l1.dataset_code)::te".toString() + "xt <> 'ety'::text) AND ((l2.dataset_code)::text <> 'ety'::text) AND ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l1.id)))) OR ((l1.dataset_code)::text <> 'eki'::text)) AND ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.entity_name)::text = 'lexeme'::text) AND (p.entity_id = l2.id)))) OR ((l2.dataset_code)::text <> 'eki'::text)))) mw\n          GROUP BY mw.lexeme_id) l_mea ON ((l_mea.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lu.lexeme_id,\n            json_agg(json_build_object('id', lu.usage_id, 'value', lu.value, 'valuePrese', lu.value_prese, 'lang', lu.lang, 'createdBy', lu.created_by, 'createdOn', lu.created_on, 'modifiedBy', lu.modified_by, 'modifiedOn', lu.modified_on, 'orderBy', lu.order_by, 'wwUnif', lu.is_ww_unif, 'wwLite', lu.is_ww_lite, 'wwOs', lu.is_ww_os, 'usageTranslationValues', lu.usage_translation_values, 'sourceLinks', lu.source_links) ORDER BY lu.order_by) AS usages\n           FROM ( SELECT u.id AS usage_id,\n                    u.lexeme_id,\n                    u.value,\n                    u.value_prese,\n                    u.lang,\n                    u.created_by,\n                    u.created_on,\n                    u.modified_by,\n                    u.modified_on,\n                    u.order_by,\n                    ( SELECT array_agg(ut.value_prese ORDER BY ut.order_by) AS array_agg\n                           FROM usage_translation ut\n                          WHERE ((ut.usage_id = u.id) AND (ut.lang = 'rus'::bpchar))) AS usage_translation_values,\n                    ( SELECT json_agg(json_build_object('sourceLinkId', usl.id, 'sourceLinkName', usl.name, 'orderBy', usl.order_by, 'sourceId', s.id, 'sourceName', s.name, 'sourceValue', s.value, 'sourceValuePrese', s.value_prese, 'sourcePublic', s.is_public) ORDER BY usl.order_by) AS json_agg\n                           FROM usage_source_link usl,\n                            source s\n                          WHERE ((usl.usage_id = u.id) AND (usl.source_id = s.id))) AS source_links,\n                    ((EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_unif'::text) AND ((p.entity_name)::text = 'usage'::text) AND (p.entity_id = u.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = u.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))) AS is_ww_unif,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_lite'::text) AND ((p.entity_name)::text = 'usage'::text) AND (p.entity_id = u.id)))) AS is_ww_lite,\n                    (EXISTS ( SELECT p.id\n                           FROM publishing p\n                          WHERE (((p.target_name)::text = 'ww_os'::text) AND ((p.entity_name)::text = 'usage'::text) AND (p.entity_id = u.id)))) AS is_ww_os\n                   FROM usage u\n                  WHERE ((u.is_public = true) AND ((EXISTS ( SELECT 1\n                           FROM publishing p\n                          WHERE (((p.entity_name)::text = 'usage'::text) AND (p.entity_id = u.id)))) OR (EXISTS ( SELECT 1\n                           FROM lexeme l_1\n                          WHERE ((l_1.id = u.lexeme_id) AND ((l_1.dataset_code)::text <> ALL ((ARRAY['eki'::character varying, 'ety'::character varying])::text[])))))))) lu\n          GROUP BY lu.lexeme_id) l_usa ON ((l_usa.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lsl.lexeme_id,\n            json_agg(json_build_object('sourceLinkId', lsl.id, 'sourceLinkName', lsl.name, 'orderBy', lsl.order_by, 'sourceId', s.id, 'sourceName', s.name, 'sourceValue', s.value, 'sourceValuePrese', s.value_prese, 'sourcePublic', s.is_public) ORDER BY lsl.lexeme_id, lsl.order_by) AS source_links\n           FROM lexeme_source_link lsl,\n            source s\n          WHERE (lsl.source_id = s.id)\n          GROUP BY lsl.lexeme_id) l_src ON ((l_src.lexeme_id = l.id)))\n  ORDER BY l.id;".toString() + ""));
    }

    /**
     * Create an aliased <code>public.view_ww_lexeme</code> table reference
     */
    public ViewWwLexeme(String alias) {
        this(DSL.name(alias), VIEW_WW_LEXEME);
    }

    /**
     * Create an aliased <code>public.view_ww_lexeme</code> table reference
     */
    public ViewWwLexeme(Name alias) {
        this(alias, VIEW_WW_LEXEME);
    }

    /**
     * Create a <code>public.view_ww_lexeme</code> table reference
     */
    public ViewWwLexeme() {
        this(DSL.name("view_ww_lexeme"), null);
    }

    public <O extends Record> ViewWwLexeme(Table<O> child, ForeignKey<O, ViewWwLexemeRecord> key) {
        super(child, key, VIEW_WW_LEXEME);
    }

    @Override
    public Schema getSchema() {
        return Public.PUBLIC;
    }

    @Override
    public ViewWwLexeme as(String alias) {
        return new ViewWwLexeme(DSL.name(alias), this);
    }

    @Override
    public ViewWwLexeme as(Name alias) {
        return new ViewWwLexeme(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public ViewWwLexeme rename(String name) {
        return new ViewWwLexeme(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public ViewWwLexeme rename(Name name) {
        return new ViewWwLexeme(name, null);
    }
}
