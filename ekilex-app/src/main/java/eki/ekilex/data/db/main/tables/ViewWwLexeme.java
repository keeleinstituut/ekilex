/*
 * This file is generated by jOOQ.
 */
package eki.ekilex.data.db.main.tables;


import eki.ekilex.data.db.main.Public;
import eki.ekilex.data.db.main.tables.records.ViewWwLexemeRecord;
import eki.ekilex.data.db.main.udt.records.TypeLangComplexityRecord;

import java.math.BigDecimal;

import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.JSON;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class ViewWwLexeme extends TableImpl<ViewWwLexemeRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.view_ww_lexeme</code>
     */
    public static final ViewWwLexeme VIEW_WW_LEXEME = new ViewWwLexeme();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<ViewWwLexemeRecord> getRecordType() {
        return ViewWwLexemeRecord.class;
    }

    /**
     * The column <code>public.view_ww_lexeme.lexeme_id</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> LEXEME_ID = createField(DSL.name("lexeme_id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.word_id</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> WORD_ID = createField(DSL.name("word_id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.meaning_id</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> MEANING_ID = createField(DSL.name("meaning_id"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_code</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> DATASET_CODE = createField(DSL.name("dataset_code"), SQLDataType.VARCHAR(10), this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_type</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> DATASET_TYPE = createField(DSL.name("dataset_type"), SQLDataType.VARCHAR(10), this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_name</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> DATASET_NAME = createField(DSL.name("dataset_name"), SQLDataType.CLOB, this, "");

    /**
     * The column <code>public.view_ww_lexeme.value_state_code</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> VALUE_STATE_CODE = createField(DSL.name("value_state_code"), SQLDataType.VARCHAR(100), this, "");

    /**
     * The column <code>public.view_ww_lexeme.proficiency_level_code</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> PROFICIENCY_LEVEL_CODE = createField(DSL.name("proficiency_level_code"), SQLDataType.VARCHAR(100), this, "");

    /**
     * The column <code>public.view_ww_lexeme.reliability</code>.
     */
    public final TableField<ViewWwLexemeRecord, Integer> RELIABILITY = createField(DSL.name("reliability"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.view_ww_lexeme.level1</code>.
     */
    public final TableField<ViewWwLexemeRecord, Integer> LEVEL1 = createField(DSL.name("level1"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.view_ww_lexeme.level2</code>.
     */
    public final TableField<ViewWwLexemeRecord, Integer> LEVEL2 = createField(DSL.name("level2"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.view_ww_lexeme.weight</code>.
     */
    public final TableField<ViewWwLexemeRecord, BigDecimal> WEIGHT = createField(DSL.name("weight"), SQLDataType.NUMERIC(5, 4), this, "");

    /**
     * The column <code>public.view_ww_lexeme.complexity</code>.
     */
    public final TableField<ViewWwLexemeRecord, String> COMPLEXITY = createField(DSL.name("complexity"), SQLDataType.VARCHAR(100), this, "");

    /**
     * The column <code>public.view_ww_lexeme.dataset_order_by</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> DATASET_ORDER_BY = createField(DSL.name("dataset_order_by"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.lexeme_order_by</code>.
     */
    public final TableField<ViewWwLexemeRecord, Long> LEXEME_ORDER_BY = createField(DSL.name("lexeme_order_by"), SQLDataType.BIGINT, this, "");

    /**
     * The column <code>public.view_ww_lexeme.lang_complexities</code>.
     */
    public final TableField<ViewWwLexemeRecord, TypeLangComplexityRecord[]> LANG_COMPLEXITIES = createField(DSL.name("lang_complexities"), eki.ekilex.data.db.main.udt.TypeLangComplexity.TYPE_LANG_COMPLEXITY.getDataType().getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.register_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> REGISTER_CODES = createField(DSL.name("register_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.pos_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> POS_CODES = createField(DSL.name("pos_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.region_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> REGION_CODES = createField(DSL.name("region_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.deriv_codes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> DERIV_CODES = createField(DSL.name("deriv_codes"), SQLDataType.VARCHAR.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.meaning_words</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> MEANING_WORDS = createField(DSL.name("meaning_words"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.advice_notes</code>.
     */
    public final TableField<ViewWwLexemeRecord, String[]> ADVICE_NOTES = createField(DSL.name("advice_notes"), SQLDataType.CLOB.getArrayDataType(), this, "");

    /**
     * The column <code>public.view_ww_lexeme.notes</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> NOTES = createField(DSL.name("notes"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.grammars</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> GRAMMARS = createField(DSL.name("grammars"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.governments</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> GOVERNMENTS = createField(DSL.name("governments"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.usages</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> USAGES = createField(DSL.name("usages"), SQLDataType.JSON, this, "");

    /**
     * The column <code>public.view_ww_lexeme.source_links</code>.
     */
    public final TableField<ViewWwLexemeRecord, JSON> SOURCE_LINKS = createField(DSL.name("source_links"), SQLDataType.JSON, this, "");

    private ViewWwLexeme(Name alias, Table<ViewWwLexemeRecord> aliased) {
        this(alias, aliased, null);
    }

    private ViewWwLexeme(Name alias, Table<ViewWwLexemeRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.view("create view \"view_ww_lexeme\" as  SELECT l.id AS lexeme_id,\n    l.word_id,\n    l.meaning_id,\n    l.dataset_code,\n    ds.type AS dataset_type,\n    ds.name AS dataset_name,\n    l.value_state_code,\n    l.proficiency_level_code,\n    l.reliability,\n    l.level1,\n    l.level2,\n    l.weight,\n    l.complexity,\n    ds.order_by AS dataset_order_by,\n    l.order_by AS lexeme_order_by,\n    l_lc.lang_complexities,\n    l_reg.register_codes,\n    l_pos.pos_codes,\n    l_rgn.region_codes,\n    l_der.deriv_codes,\n    mw.meaning_words,\n    anote.advice_notes,\n    pnote.notes,\n    gramm.grammars,\n    gov.governments,\n    usg.usages,\n    lsl.source_links\n   FROM (((((((((((((lexeme l\n     JOIN dataset ds ON ((((ds.code)::text = (l.dataset_code)::text) AND (ds.is_public = true))))\n     LEFT JOIN ( SELECT l_reg_1.lexeme_id,\n            array_agg(l_reg_1.register_code ORDER BY l_reg_1.order_by) AS register_codes\n           FROM lexeme_register l_reg_1\n          GROUP BY l_reg_1.lexeme_id) l_reg ON ((l_reg.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT l_pos_1.lexeme_id,\n            array_agg(l_pos_1.pos_code ORDER BY l_pos_1.order_by) AS pos_codes\n           FROM lexeme_pos l_pos_1\n          GROUP BY l_pos_1.lexeme_id) l_pos ON ((l_pos.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT l_rgn_1.lexeme_id,\n            array_agg(l_rgn_1.region_code ORDER BY l_rgn_1.order_by) AS region_codes\n           FROM lexeme_region l_rgn_1\n          GROUP BY l_rgn_1.lexeme_id) l_rgn ON ((l_rgn.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT l_der_1.lexeme_id,\n            array_agg(l_der_1.deriv_code) AS deriv_codes\n           FROM lexeme_deriv l_der_1\n          GROUP BY l_der_1.lexeme_id) l_der ON ((l_der.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lf.lexeme_id,\n            array_agg(ff.value ORDER BY ff.order_by) AS advice_notes\n           FROM lexeme_freeform lf,\n            freeform ff\n          WHERE ((lf.freeform_id = ff.id) AND ((ff.freeform_type_code)::text = 'ADVICE_NOTE'::text))\n          GROUP BY lf.lexeme_id) anote ON ((anote.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT ln.lexeme_id,\n            json_agg(ROW(ln.lexeme_note_id, ln.value, ln.value_prese, ln.lang, ln.complexity, ln.created_by, ln.created_on, ln.modified_by, ln.modified_on, ln.source_links)::type_note ORDER BY ln.order_by) AS notes\n           FROM ( SELECT ln_1.lexeme_id,\n                    ln_1.id AS lexeme_note_id,\n                    ln_1.value,\n                    ln_1.value_prese,\n                    ln_1.lang,\n                    ln_1.complexity,\n                    ln_1.created_by,\n                    ln_1.created_on,\n                    ln_1.modified_by,\n                    ln_1.modified_on,\n                    ln_1.order_by,\n                    lnsl.source_links\n                   FROM (lexeme_note ln_1\n                     LEFT JOIN ( SELECT lnsl_1.lexeme_note_id,\n                            json_agg(ROW(lnsl_1.id, lnsl_1.type, lnsl_1.name, lnsl_1.order_by, s.id, s.name, s.value, s.value_prese, s.is_public)::type_source_link ORDER BY lnsl_1.lexeme_note_id, lnsl_1.order_by) AS source_links\n                           FROM lexeme_note_source_link lnsl_1,\n                            source s\n                          WHERE (lnsl_1.source_id = s.id)\n                          GROUP BY lnsl_1.lexeme_note_id) lnsl ON ((lnsl.lexeme_note_id = ln_1.id)))\n                  WHERE (ln_1.is_public = true)) ln\n          GROUP BY ln.lexeme_id) pnote ON ((pnote.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lf.lexeme_id,\n            json_agg(ROW(ff.id, ff.freeform_type_code, ff.value_prese, ff.lang, ff.complexity, NULL::text, NULL::timestamp without time zone, NULL::text, NULL::timestamp without time zone)::type_freeform ORDER BY ff.order_by) AS grammars\n           FROM lexeme_freeform lf,\n            freeform ff\n          WHERE ((lf.freeform_id = ff.id) AND ((ff.freeform_type_code)::text = 'GRAMMAR'::text))\n          GROUP BY lf.lexeme_id) gramm ON ((gramm.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lf.lexeme_id,\n            json_agg(ROW(ff.id, ff.freeform_type_code, ff.value_prese, ff.lang, ff.complexity, NULL::text, NULL::timestamp without time zone, NULL::text, NULL::timestamp without time zone)::type_freeform ORDER BY ff.order_by) AS governments\n           FROM lexeme_freeform lf,\n            freeform ff\n          WHERE ((lf.freeform_id = ff.id) AND ((ff.freeform_type_code)::text = 'GOVERNMENT'::text))\n          GROUP BY lf.lexeme_id) gov ON ((gov.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT mw_1.lexeme_id,\n            json_agg(ROW(mw_1.lexeme_id, mw_1.meaning_id, mw_1.mw_lex_id, mw_1.mw_lex_complexity, mw_1.mw_lex_weight, (mw_1.mw_lex_governments)::json, (mw_1.mw_lex_register_codes)::character varying(100)[], mw_1.mw_lex_value_state_code, mw_1.mw_word_id, mw_1.mw_word, mw_1.mw_word_prese, mw_1.mw_homonym_nr, mw_1.mw_lang, mw_1.mw_aspect_code, (mw_1.mw_word_type_codes)::character varying(100)[])::type_meaning_word ORDER BY mw_1.hw_lex_reliability, mw_1.hw_lex_level1, mw_1.hw_lex_level2, mw_1.hw_lex_order_by, mw_1.mw_lex_order_by) AS meaning_words\n           FROM ( SELECT DISTINCT l1.word_id,\n                    l1.id AS lexeme_id,\n                    l1.meaning_id,\n                    l1.level2 AS hw_lex_reliability,\n                    l1.level1 AS hw_lex_level1,\n                    l1.level2 AS hw_lex_level2,\n                    l1.order_by AS hw_lex_order_by,\n                    l2.id AS mw_lex_id,\n                    l2.complexity AS mw_lex_complexity,\n                    l2.weight AS mw_lex_weight,\n                    ( SELECT jsonb_agg(ROW(ff.id, ff.freeform_type_code, ff.value, ff.lang, ff.complexity, NULL::text, NULL::timestamp without time zone, NULL::text, NULL::timestamp without time zone)::type_freeform ORDER BY ff.order_by) AS jsonb_agg\n                           FROM lexeme_freeform lf,\n                            freeform ff\n                          WHERE ((lf.lexeme_id = l2.id) AND (lf.freeform_id = ff.id) AND ((ff.freeform_type_code)::text = 'GOVERNMENT'::text))\n                          GROUP BY lf.lexeme_id) AS mw_lex_governments,\n                    ( SELECT array_agg(l_reg_1.register_code ORDER BY l_reg_1.order_by) AS array_agg\n                           FROM lexeme_register l_reg_1\n                          WHERE (l_reg_1.lexeme_id = l2.id)\n                          GROUP BY l_reg_1.lexeme_id) AS mw_lex_register_codes,\n                    l2.value_state_code AS mw_lex_value_state_code,\n                    w2.id AS mw_word_id,\n                    w2.value AS mw_word,\n                    w2.value_prese AS mw_word_prese,\n                    w2.homonym_nr AS mw_homonym_nr,\n                    w2.lang AS mw_lang,\n                    ( SELECT array_agg(wt.word_type_code ORDER BY wt.order_by) AS array_agg\n                           FROM word_word_type wt\n                          WHERE ((wt.word_id = w2.id) AND ((wt.word_type_code)::text <> ALL ((ARRAY['vv'::character varying, 'yv'::character varying, 'vvar'::character varying])::text[])))\n                          GROUP BY wt.word_id) AS mw_word_type_codes,\n                    w2.aspect_code AS mw_aspect_code,\n                    l2.order_by AS mw_lex_order_by\n                   FROM ((((lexeme l1\n                     JOIN dataset l1ds ON (((l1ds.code)::text = (l1.dataset_code)::text)))\n                     JOIN lexeme l2 ON ((l2.meaning_id = l1.meaning_id)))\n                     JOIN dataset l2ds ON (((l2ds.code)::text = (l2.dataset_code)::text)))\n                     JOIN word w2 ON ((w2.id = l2.word_id)))\n                  WHERE ((l1.is_public = true) AND (l1.is_word = true) AND (l1ds.is_public = true) AND (l2.is_public = true) AND (w2.is_public = true) AND (l2ds.is_public = true) AND ((COALESCE(l2.value_state_code, 'anything'::character varying))::text <> 'vigane'::text))) mw_1\n          GROUP BY mw_1.lexeme_id) mw ON ((mw.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT u.lexeme_id,\n            json_agg(ROW(u.usage_id, u.value, u.value_prese, u.lang, u.complexity, u.usage_translations, u.usage_definitions, u.source_links)::type_usage ORDER BY u.order_by) AS usages\n           FROM ( SELECT u_1.lexeme_id,\n                    u_1.id AS usage_id,\n                    u_1.value,\n                    u_1.value_prese,\n                    u_1.lang,\n                    u_1.complexity,\n                    u_1.order_by,\n                    ut.usage_translations,\n                    ud.usage_definitions,\n                    usl.source_links\n                   FROM (((usage u_1\n                     LEFT JOIN ( SELECT usl_1.usage_id,\n                            json_agg(ROW(usl_1.id, usl_1.type, usl_1.name, usl_1.order_by, s.id, s.name, s.value, s.value_prese, s.is_public)::type_source_link ORDER BY usl_1.usage_id, usl_1.order_by) AS source_links\n                           FROM usage_source_link usl_1,\n                            source s\n                          WHERE (usl_1.source_id = s.id)\n                          GROUP BY usl_1.usage_id) usl ON ((usl.usage_id = u_1.id)))\n                     LEFT JOIN ( SELECT ut_1.usage_id,\n                            array_agg(ut_1.value_prese ORDER BY ut_1.order_by) AS usage_translations\n                           FROM usage_translation ut_1\n                          WHERE (ut_1.lang = 'rus'::bpchar)\n                          GROUP BY ut_1.usage_id) ut ON ((ut.usage_id = u_1.id)))\n                     LEFT JOIN ( SELECT ud_1.usage_id,\n                            array_agg(ud_1.value_prese ORDER BY ud_1.order_by) AS usage_definitions\n                           FROM usage_definition ud_1\n                          GROUP BY ud_1.usage_id) ud ON ((ud.usage_id = u_1.id)))\n                  WHERE (u_1.is_public = true)) u\n          GROUP BY u.lexeme_id) usg ON ((usg.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lsl_1.lexeme_id,\n            json_agg(ROW(lsl_1.id, lsl_1.type, lsl_1.name, lsl_1.order_by, s.id, s.name, s.value, s.value_prese, s.is_public)::type_source_link ORDER BY lsl_1.lexeme_id, lsl_1.order_by) AS source_links\n           FROM lexeme_source_link lsl_1,\n            source s\n          WHERE (lsl_1.source_id = s.id)\n          GROUP BY lsl_1.lexeme_id) lsl ON ((lsl.lexeme_id = l.id)))\n     LEFT JOIN ( SELECT lc.id,\n            array_agg(DISTINCT ROW((\n                CASE\n                    WHEN (lc.lang = ANY (ARRAY['est'::bpchar, 'rus'::bpchar, 'eng'::bpchar, 'ukr'::bpchar, 'fra'::bpchar])) THEN lc.lang\n                    ELSE 'other'::bpchar\n                END)::character varying(10), lc.dataset_code, lc.lex_complexity, (TRIM(TRAILING '12'::text FROM lc.data_complexity))::character varying(100))::type_lang_complexity) AS lang_complexities\n           FROM ( SELECT l1.id,\n                    w2.lang,\n                    l1.dataset_code,\n                    l1.complexity AS lex_complexity,\n                    l2.complexity AS data_complexity\n                   FROM ((((lexeme l1\n                     JOIN dataset l1ds ON ((((l1ds.code)::text = (l1.dataset_code)::text) AND (l1ds.is_public = true))))\n                     JOIN lexeme l2 ON (((l2.meaning_id = l1.meaning_id) AND ((l2.dataset_code)::text = (l1.dataset_code)::text) AND (l2.is_public = true) AND (l2.is_word = true) AND (l2.word_id <> l1.word_id))))\n                     JOIN dataset l2ds ON ((((l2ds.code)::text = (l2.dataset_code)::text) AND (l2ds.is_public = true))))\n                     JOIN word w2 ON ((w2.id = l2.word_id)))\n                  WHERE ((l1.is_public = true) AND (l1.is_word = true))\n                UNION ALL\n                 SELECT l_1.id,\n                    COALESCE(ff.lang, w.lang) AS lang,\n                    l_1.dataset_code,\n                    l_1.complexity AS lex_complexity,\n                    ff.complexity AS data_complexity\n                   FROM word w,\n                    lexeme l_1,\n                    lexeme_freeform lff,\n                    freeform ff,\n                    dataset ds_1\n                  WHERE ((l_1.is_public = true) AND (l_1.is_word = true) AND (l_1.word_id = w.id) AND ((l_1.dataset_code)::text = (ds_1.code)::text) AND (ds_1.is_public = true) AND (w.is_public = true) AND (lff.lexeme_id = l_1.id) AND (lff.freeform_id = ff.id) AND ((ff.freeform_type_code)::text = ANY ((ARRAY['GRAMMAR'::character varying, 'GOVERNMENT'::character varying])::text[])))\n                UNION ALL\n                 SELECT l_1.id,\n                    COALESCE(ln.lang, w.lang) AS lang,\n                    l_1.dataset_code,\n                    l_1.complexity AS lex_complexity,\n                    ln.complexity AS data_complexity\n                   FROM word w,\n                    lexeme l_1,\n                    lexeme_note ln,\n                    dataset ds_1\n                  WHERE ((l_1.is_public = true) AND (l_1.is_word = true) AND (l_1.word_id = w.id) AND ((l_1.dataset_code)::text = (ds_1.code)::text) AND (ds_1.is_public = true) AND (w.is_public = true) AND (ln.lexeme_id = l_1.id) AND (ln.is_public = true))\n                UNION ALL\n                 SELECT l_1.id,\n                    COALESCE(u.lang, w.lang) AS lang,\n                    l_1.dataset_code,\n                    l_1.complexity AS lex_complexity,\n                    u.complexity AS data_complexity\n                   FROM word w,\n                    lexeme l_1,\n                    usage u,\n                    dataset ds_1\n                  WHERE ((l_1.is_public = true) AND (l_1.is_word = true) AND ((l_1.dataset_code)::text = (ds_1.code)::text) AND (ds_1.is_public = true) AND (u.lexeme_id = l_1.id) AND (u.is_public = true))\n                UNION ALL\n                 SELECT l_1.id,\n                    ut.lang,\n                    l_1.dataset_code,\n                    l_1.complexity AS lex_complexity,\n                    u.complexity AS data_complexity\n                   FROM lexeme l_1,\n                    usage u,\n                    usage_translation ut,\n                    dataset ds_1\n                  WHERE ((l_1.is_public = true) AND (l_1.is_word = true) AND ((l_1.dataset_code)::text = (ds_1.code)::text) AND (ds_1.is_public = true) AND (u.lexeme_id = l_1.id) AND (u.is_public = true) AND (ut.usage_id = u.id))\n                UNION ALL\n                 SELECT l_1.id,\n                    d.lang,\n                    l_1.dataset_code,\n                    l_1.complexity AS lex_complexity,\n                    d.complexity AS data_complexity\n                   FROM lexeme l_1,\n                    definition d,\n                    dataset ds_1\n                  WHERE ((l_1.is_public = true) AND (l_1.meaning_id = d.meaning_id) AND (d.is_public = true) AND ((ds_1.code)::text = (l_1.dataset_code)::text) AND (ds_1.is_public = true))\n                UNION ALL\n                 SELECT l1.id,\n                    w2.lang,\n                    l1.dataset_code,\n                    l1.complexity AS lex_complexity,\n                    l2.complexity AS data_complexity\n                   FROM lex_relation r,\n                    lexeme l1,\n                    lexeme l2,\n                    word w2,\n                    dataset l1ds,\n                    dataset l2ds\n                  WHERE ((l1.is_public = true) AND (l1.is_word = true) AND ((l1ds.code)::text = (l1.dataset_code)::text) AND (l1ds.is_public = true) AND (r.lexeme1_id = l1.id) AND (r.lexeme2_id = l2.id) AND ((l2.dataset_code)::text = (l1.dataset_code)::text) AND (l2.is_public = true) AND (l2.is_word = true) AND ((l2ds.code)::text = (l2.dataset_code)::text) AND (l2ds.is_public = true) AND (w2.id = l2.word_id) AND (w2.is_public = true))\n                UNION ALL\n                 SELECT l1.id,\n                    w1.lang,\n                    l1.dataset_code,\n                    l1.complexity AS lex_complexity,\n                    l1.complexity AS data_complexity\n                   FROM lexeme l1,\n                    word w1,\n                    dataset l1ds\n                  WHERE ((l1.is_public = true) AND (l1.is_word = true) AND ((l1ds.code)::text = (l1.dataset_code)::text) AND (l1ds.is_public = true) AND (w1.id = l1.word_id) AND (w1.is_public = true) AND (NOT (EXISTS ( SELECT l2.id\n                           FROM lexeme l2,\n                            dataset l2ds\n                          WHERE ((l2.meaning_id = l1.meaning_id) AND ((l2.dataset_code)::text = (l1.dataset_code)::text) AND (l2.id <> l1.id) AND (l2.is_public = true) AND (l2.is_word = true) AND ((l2ds.code)::text = (l2.dataset_code)::text) AND (l2ds.is_public = true))))) AND (NOT (EXISTS ( SELECT d.id\n                           FROM definition d\n                          WHERE ((d.meaning_id = l1.meaning_id) AND (d.is_public = true))))) AND (NOT (EXISTS ( SELECT ln.id\n                           FROM lexeme_note ln\n                          WHERE ((ln.lexeme_id = l1.id) AND (ln.is_public = true))))) AND (NOT (EXISTS ( SELECT u.id\n                           FROM usage u\n                          WHERE ((u.lexeme_id = l1.id) AND (u.is_public = true))))) AND (NOT (EXISTS ( SELECT ff.id\n                           FROM lexeme_freeform lff,\n                            freeform ff\n                          WHERE ((lff.lexeme_id = l1.id) AND (lff.freeform_id = ff.id) AND ((ff.freeform_type_code)::text = ANY ((ARRAY['GRAMMAR'::character varying, 'GOVERNMENT'::character varying])::text[])))))))) lc\n          GROUP BY lc.id) l_lc ON ((l_lc.id = l.id)))\n  WHERE ((l.is_public = true) AND (l.is_word = true))\n  ORDER BY l.id;"));
    }

    /**
     * Create an aliased <code>public.view_ww_lexeme</code> table reference
     */
    public ViewWwLexeme(String alias) {
        this(DSL.name(alias), VIEW_WW_LEXEME);
    }

    /**
     * Create an aliased <code>public.view_ww_lexeme</code> table reference
     */
    public ViewWwLexeme(Name alias) {
        this(alias, VIEW_WW_LEXEME);
    }

    /**
     * Create a <code>public.view_ww_lexeme</code> table reference
     */
    public ViewWwLexeme() {
        this(DSL.name("view_ww_lexeme"), null);
    }

    public <O extends Record> ViewWwLexeme(Table<O> child, ForeignKey<O, ViewWwLexemeRecord> key) {
        super(child, key, VIEW_WW_LEXEME);
    }

    @Override
    public Schema getSchema() {
        return Public.PUBLIC;
    }

    @Override
    public ViewWwLexeme as(String alias) {
        return new ViewWwLexeme(DSL.name(alias), this);
    }

    @Override
    public ViewWwLexeme as(Name alias) {
        return new ViewWwLexeme(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public ViewWwLexeme rename(String name) {
        return new ViewWwLexeme(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public ViewWwLexeme rename(Name name) {
        return new ViewWwLexeme(name, null);
    }
}
